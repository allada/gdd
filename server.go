package main

import (
    "./protocol"
    "net/http"
    "fmt"
    //"bytes"
    "crypto/sha1"
    "io"
    "io/ioutil"
    "os"
    "strings"
    "time"
    "encoding/hex"

    "os/exec"

    "encoding/json"
    "golang.org/x/net/websocket"
    "github.com/derekparker/delve/service/rpc2"
    "github.com/derekparker/delve/service/api"
)

var started bool = false
var dbgClient* rpc2.RPCClient

func outputStream(reader io.Reader) {
    for {
        var buf []byte
        sz, err := reader.Read(buf)
        if err != nil {
            return;
        }
        //buf := stdout.Bytes()
        if sz == 0 {
            time.Sleep(100 * time.Millisecond)
            continue;
        }
        fmt.Println(string(buf))
    }
}

var currentPort int = 8180
var minPort int = 8180
var maxPort int = 8281

// Echo the data received on the WebSocket.
func initializeConnection(ws *websocket.Conn) {
    workingDir, _ := os.Getwd()
    if currentPort + 1 > maxPort {
        currentPort = minPort
    } else {
        currentPort = currentPort + 1
    }
    cmd := exec.Command("/Users/allada/GoogleDrive/projects/go/bin/dlv", "debug", "--headless", "--build-flags=-gcflags='-N -l'", "--api-version=2", "--listen=localhost:" + fmt.Sprintf("%d", currentPort), "./helloworld.go")
    stdout, err := cmd.StdoutPipe()
    if err != nil {
        panic(err)
    }
    stdin, err := cmd.StdinPipe()
    if err != nil {
        panic(err)
    }
    stderr, err := cmd.StderrPipe()
    if err != nil {
        panic(err)
    }
    if err := cmd.Start(); err != nil {
        panic(err)
    }
    io.WriteString(stdin, "values written to stdin are passed to cmd's standard input")

    go outputStream(stdout);
    go outputStream(stderr);
    go func() {
        time.Sleep(300 * time.Millisecond)
        // var data map[string]interface{}
        // strings.NewReader(jsonStream)
        // if err := json.NewDecoder(stdout).Decode(&data); err != nil {
        //     panic(err)
        // }
        // if err := cmd.Wait(); err != nil {
        //     panic(err)
        // }
        dbgClient = rpc2.NewClient("localhost:" + fmt.Sprintf("%d", currentPort))
        //fmt.Printf("PID: %d\n", dbgClient.ProcessPid())
        scope, _ := dbgClient.FindLocation(api.EvalScope{
            GoroutineID: -1,
            Frame: 0,
        }, "main.main")
        dbgClient.CreateBreakpoint(&api.Breakpoint{
            Addr: scope[0].PC,
            Name: "mainBreak",
        })
        state :=<-dbgClient.Continue()
        // fmt.Printf("\nScope: %+v\n", state1)

        // fmt.Printf("\nScope: %+v\n", scope)

        // state, _ := dbgClient.GetState()
        // fmt.Printf("state: %+v\n", state)

        sources, _ := dbgClient.ListSources("")
        //fmt.Printf("%+v\n", sources)
        // fmt.Println(data)

        for _, source := range sources {
            if source == "<autogenerated>" {
                continue;
            }
            scriptId := source
            if strings.HasPrefix(source, workingDir) {
                //source = source[len(workingDir):]
            }

            send(ws, protocol.Response{
                Method: "Debugger.scriptParsed",
                Params: protocol.ScriptParsed{
                    ScriptId: scriptId,
                    Url: source,
                    ExecutionContextId: 12345,
                },
            })
        }
        sendPauseEvent(ws, state)
        //breakpoint := dbgClient.Restart()
        fmt.Print("Here: \n")
        //fmt.Printf("%+v\n", breakpoint)

    }()

    for {
        var message []byte
        websocket.Message.Receive(ws, &message)
        fmt.Print("Recv: ")
        fmt.Println(string(message))

        var jsonData map[string]interface{}
        if err := json.Unmarshal(message, &jsonData); err != nil {
            panic(err)
        }
        id := int(jsonData["id"].(float64))
        switch jsonData["method"] {
        case "Console.enable":
            go send(ws, protocol.Result{Id: id, Result: struct{}{}})
        //case "Network.setCacheDisabled":
        case "Page.enable":
            go send(ws, protocol.Result{Id: id, Result: struct{}{}})
        //case "Page.getResourceTree":
        case "Runtime.enable":
            go send(ws, protocol.Result{Id: id, Result: struct{}{}})
        case "Debugger.enable":
            go send(ws, protocol.Result{Id: id, Result: struct{}{}})
        // case "Debugger.setPauseOnExceptions":
        // case "Debugger.setAsyncCallStackDepth":
        // case "DOM.enable":
        // case "CSS.enable":
        case "Debugger.resume":
            state :=<-dbgClient.Continue()
            if state != nil {
                sendPauseEvent(ws, state)
            }
        case "Debugger.stepOver":
            go func() {
                state, _ := dbgClient.Next()
                //state, _ := dbgClient.Next()
                if state != nil {
                    sendPauseEvent(ws, nil)
                }
            }()
        case "Debugger.stepOut":
            go func() {
                state, _ := dbgClient.StepOut()
                if state != nil {
                    sendPauseEvent(ws, state)
                }
            }()
        case "Debugger.stepInto":
            go func() {
                state, _ := dbgClient.Step()
                //state, _ := dbgClient.Next()
                if state != nil {
                    sendPauseEvent(ws, nil)
                }
            }()
        case "Worker.enable":
            go send(ws, protocol.Result{Id: id, Result: struct{}{}})
        case "Debugger.setPauseOnExceptions":
            go send(ws, protocol.Result{Id: id, Result: struct{}{}})
        case "Debugger.setBlackboxPatterns":
            go send(ws, protocol.Result{Id: id, Result: struct{}{}})
        case "Profiler.setSamplingInterval":
            go send(ws, protocol.Result{Id: id, Result: struct{}{}})
        case "Debugger.setAsyncCallStackDepth":
            go send(ws, protocol.Result{Id: id, Result: struct{}{}})
        case "Runtime.runIfWaitingForDebugger":
            go send(ws, protocol.Result{Id: id, Result: struct{}{}})
        case "Profiler.enable":
            go send(ws, protocol.Result{Id: id, Result: struct{}{}})
        // case "Profiler.setSamplingInterval":
        // case "ServiceWorker.enable":
        // case "Network.canEmulateNetworkConditions":
        // case "Debugger.setBlackboxPatterns":
        // case "Page.setAutoAttachToCreatedPages":
        // case "Emulation.setScriptExecutionDisabled":
        // case "Rendering.setShowViewportSizeOnResize":
        // case "Runetime.run":
        // case "Inspector.enable":
        case "Debugger.setBreakpointByUrl":
            data := jsonData["params"].(map[string]interface{})
            go createBreakpoint(ws, id, data["url"].(string), int(data["lineNumber"].(float64)))
        case "Debugger.getScriptSource":
            go getSource(ws, id, jsonData["params"].(map[string]interface{})["scriptId"].(string))
        default:
            go send(ws, protocol.ErrorResult{Id: id, Status: protocol.StatusCodeError, Error: protocol.ErrorResponse{
                Code: protocol.ErrorCodeMethodNotFound,
            }})
        }
    }
}

func sendPauseEvent(ws *websocket.Conn, state *api.DebuggerState) {
    sendGoRoutines(ws)

    callFrames := []protocol.DebuggerCallFrame{}
    if state == nil {
        state, _ = dbgClient.GetState()
    }
    fmt.Printf("State: %+v\n\n", state)
    stacks, _ := dbgClient.Stacktrace(state.SelectedGoroutine.ID, 50, &api.LoadConfig{
        FollowPointers: true,
        MaxVariableRecurse: 1,
        MaxStringLen: 1,
        MaxArrayValues: 1,
        MaxStructFields: 1,
    })
    // fmt.Printf("Stacktrace: %+v", stacks)

    for index, stack := range stacks {
        functionName := "Unknown"
        if stack.Location.Function != nil {
            functionName = stack.Location.Function.Name
        }
        callFrames = append(callFrames, protocol.DebuggerCallFrame{
            CallFrameId: fmt.Sprintf("%d", index),
            FunctionName: functionName,
            Location: protocol.DebuggerLocation{
                ScriptId: stack.Location.File,
                LineNumber: stack.Location.Line - 1, // Always -1
            },
            ScopeChain: []protocol.DebuggerScope{},
            This: protocol.RuntimeRemoteObject{
                Type: "undefined",
            },
            ReturnValue: nil,
        })
    }

    send(ws, protocol.Response{
        Method: "Debugger.paused",
        Params: protocol.DebuggerPausedEvent{
            Reason: "other",
            CallFrames: callFrames,
        },
    })
}

func sendGoRoutines(ws *websocket.Conn) {
    goroutines, _ := dbgClient.ListGoroutines()
    send(ws, protocol.Response{Method: "Debugger.executionContextsCleared", Params: struct{}{}})
    for _, goroutine := range goroutines {
        // fmt.Printf("Thread: %+v\n", thread)

        // send(ws, protocol.Response{
        //     Method: "Runtime.executionContextCreated",
        //     Params: TargetInfo{
        //         ID: fmt.Sprintf("%d", goroutine.ID),
        //         Type: "",
        //         Title: fmt.Sprintf("%d", goroutine.ID),
        //         Url: fmt.Sprintf("%d", goroutine.ID),
        //     },
        // })
        send(ws, protocol.Response{
            Method: "Runtime.executionContextCreated",
            Params: protocol.CreateExecutionContext{
                Context: protocol.ExecutionContextDescription{
                    Id: goroutine.ID,
                    Name: goroutine.UserCurrentLoc.File,
                    Origin: "://",
                    // AuxData: protocol.ExecutionContextDescriptionAuxData{
                    //     IsDefault: true,
                    // },
                },
            },
        })
    }
}

func createBreakpoint(ws *websocket.Conn, id int, file string, lineNumber int) {
    lineNumber++ // Line numbers are always +1 in devtools
    nameHash := sha1.New()
    io.WriteString(nameHash, fmt.Sprintf("%s:%d", file, lineNumber))
    name := hex.EncodeToString(nameHash.Sum(nil))
    var breakpoint *api.Breakpoint
    var err error
    breakpoint, err = dbgClient.CreateBreakpoint(&api.Breakpoint{
        File: file,
        Name: name,
        Line: lineNumber,
    })
    var actualLocation []protocol.DebuggerLocation
    status := protocol.StatusCodeSuccess
    breakpointId := ""
    if err != nil {
        breakpoint, err = dbgClient.GetBreakpointByName(name)
    }
    if err == nil {
        breakpointId = string(breakpoint.ID)
        status = protocol.StatusCodeFallThrough
        actualLocation = []protocol.DebuggerLocation{
            {
                ScriptId: breakpoint.File,
                LineNumber: breakpoint.Line,
            },
        }
    }
    // fmt.Printf("%+v\n", breakpoint)
    go send(ws, protocol.Result{
        Id: id,
        Status: status,
        Result: protocol.DebuggerSetBreakpointByUrlResponse{
            BreakpointId: breakpointId,
            ActualLocation: actualLocation,
        },
    })
}

func getSource(ws *websocket.Conn, id int, path string) {
    data, err := ioutil.ReadFile(path)
    if err != nil {
        fmt.Println("File Not found: ", path)
        return
    }
    send(ws, protocol.Result{
        Id: id,
        Result: protocol.ScriptSourceResult{
            ScriptSource: string(data),
        },
    })
}

func send(ws *websocket.Conn, data interface{}) {
    fmt.Print("Send: \x1b[31m")
    outData, _ := json.Marshal(data)
    outString := string(outData)
    fmt.Println(outString)
    fmt.Print("\x1b[0m")
    websocket.Message.Send(ws, outString)
}

// This example demonstrates a trivial echo server.
func main() {
    fmt.Println()
    fmt.Println()
    fmt.Println()
    fmt.Println()
    http.Handle("/go-devtools-debug", websocket.Handler(initializeConnection))
    err := http.ListenAndServe(":9922", nil)
    if err != nil {
        panic("ListenAndServe: " + err.Error())
    }
}