package debugger

import (
    "fmt"
    "io/ioutil"
    "strconv"
    "../../dbgClient"
    "../../protocol/shared"
    debuggerAgent "../../protocol/debugger"
    runtimeAgent "../../protocol/runtime"
    targetAgent "../../protocol/target"
)

type goroutineID int

type Target struct {
    ID goroutineID
    Proxy *proxy
}

func (t *Target) Attach() {
    t.Proxy.target.FireAttachedToTarget(targetAgent.AttachedToTargetEvent{
        TargetInfo: targetAgent.TargetInfo{
            TargetId: targetAgent.TargetID(fmt.Sprintf("%d", t.ID)),
            Type: "worker",
            Title: "asdf",
            Url: "asdf",
        },
        WaitingForDebugger: false,
    })

    for _, file := range t.Proxy.fileList {
        t.Proxy.agent.FireScriptParsedOnTarget(fmt.Sprintf("%d", t.ID), debuggerAgent.ScriptParsedEvent{
            ScriptId: runtimeAgent.ScriptId(file),
            Url: file,
            ExecutionContextId: 1,
        })
    }
}

func (t *Target) Destroy() {
    t.Proxy.target.FireDetachedFromTarget(targetAgent.DetachedFromTargetEvent{
        TargetId: targetAgent.TargetID(fmt.Sprintf("%d", t.ID)),
    })
}

func (t *Target) FirePaused(callframes []dbgClient.Stackframe) {
    sendFrames := []debuggerAgent.CallFrame{}
    for index, frame := range callframes {
        functionName := "<Unknown>"
        if frame.Location.Function != nil {
            functionName = frame.Location.Function.Name
        }
        sendFrames = append(sendFrames, debuggerAgent.CallFrame{
            CallFrameId: debuggerAgent.CallFrameId(fmt.Sprintf("%d", index)),
            FunctionName: functionName,
            Location: debuggerAgent.Location{
                ScriptId: runtimeAgent.ScriptId(frame.Location.File),
                LineNumber: int64(frame.Location.Line - 1), // Always -1
            },
            ScopeChain: []debuggerAgent.Scope{},
            This: runtimeAgent.RemoteObject{
                Type: "undefined",
            },
            ReturnValue: nil,
        })
    }
    t.Proxy.agent.FirePausedOnTarget(fmt.Sprintf("%d", t.ID), debuggerAgent.PausedEvent{
        Reason: "other",
        CallFrames: sendFrames,
    })
}

type proxy struct {
    agent *debuggerAgent.DebuggerAgent
    target *targetAgent.TargetAgent
    client *dbgClient.Client
    activeTargets map[goroutineID]*Target
    fileList []string
    activeGoroutineID goroutineID
}

func NewProxy(conn *shared.Connection, client *dbgClient.Client) *proxy {
    agent := debuggerAgent.NewAgent(conn)
    target := targetAgent.NewAgent(conn)
    return &proxy{
        agent: agent,
        target: target,
        client: client,
        activeTargets: map[goroutineID]*Target{},
    }
}

func (p *proxy) Start() {
    // Wait until we are enabled.
    command := <-p.agent.EnableNotify()
    command.Respond()

    go p.handleNotifications()

    // Wait until debugger is ready.
    p.client.BlockUntilReady()

    go p.sendPauseState()

    sources, err := p.client.ListSources()
    if err != nil {
        panic(err)
    }

    for _, source := range sources {
        if source == "<autogenerated>" {
            continue;
        }
        p.fileList = append(p.fileList, source)
        p.agent.FireScriptParsed(debuggerAgent.ScriptParsedEvent{
            ScriptId: runtimeAgent.ScriptId(source),
            Url: source,
            ExecutionContextId: 1,
        })
    }
}

func (p *proxy) handleNotifications() {
    enable                  := p.agent.EnableNotify()
    disable                 := p.agent.DisableNotify()
    setBreakpointsActive    := p.agent.SetBreakpointsActiveNotify()
    setSkipAllPauses        := p.agent.SetSkipAllPausesNotify()
    setBreakpointByUrl      := p.agent.SetBreakpointByUrlNotify()
    setBreakpoint           := p.agent.SetBreakpointNotify()
    removeBreakpoint        := p.agent.RemoveBreakpointNotify()
    getPossibleBreakpoints  := p.agent.GetPossibleBreakpointsNotify()
    continueToLocation      := p.agent.ContinueToLocationNotify()
    stepOver                := p.agent.StepOverNotify()
    stepInto                := p.agent.StepIntoNotify()
    stepOut                 := p.agent.StepOutNotify()
    pause                   := p.agent.PauseNotify()
    resume                  := p.agent.ResumeNotify()
    searchInContent         := p.agent.SearchInContentNotify()
    setScriptSource         := p.agent.SetScriptSourceNotify()
    restartFrame            := p.agent.RestartFrameNotify()
    getScriptSource         := p.agent.GetScriptSourceNotify()
    setPauseOnExceptions    := p.agent.SetPauseOnExceptionsNotify()
    evaluateOnCallFrame     := p.agent.EvaluateOnCallFrameNotify()
    setVariableValue        := p.agent.SetVariableValueNotify()
    setAsyncCallStackDepth  := p.agent.SetAsyncCallStackDepthNotify()
    setBlackboxPatterns     := p.agent.SetBlackboxPatternsNotify()
    setBlackboxedRanges     := p.agent.SetBlackboxedRangesNotify()
    // TODO bail out properly on closed.
    for {
        select {
        case command := <-enable:
            command.Respond()
            //command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-disable:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-setBreakpointsActive:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-setSkipAllPauses:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-setBreakpointByUrl:
            go p.setBreakpointAndRespond(command)
        case command := <-setBreakpoint:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-removeBreakpoint:
            go p.removeBreakpointAndRespond(command)
        case command := <-getPossibleBreakpoints:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-continueToLocation:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-stepOver:
            go p.stepOverAndRespond(command)
        case command := <-stepInto:
            go p.stepIntoAndRespond(command)
        case command := <-stepOut:
            go p.stepOutAndRespond(command)
        case command := <-pause:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-resume:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-searchInContent:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-setScriptSource:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-restartFrame:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-getScriptSource:
            // TODO this should be secure
            go getFileAndRespond(command)
        case command := <-setPauseOnExceptions:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-evaluateOnCallFrame:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-setVariableValue:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-setAsyncCallStackDepth:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-setBlackboxPatterns:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-setBlackboxedRanges:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        }
    }
}

func buildLocation(file string, line int) debuggerAgent.Location {
    return debuggerAgent.Location{
        ScriptId: runtimeAgent.ScriptId(file),
        LineNumber: int64(line),
    }
}

func (p *proxy) continueAndRespond(command debuggerAgent.StepOverCommand) {
    if command.DestinationTargetID != "" {
        if targetID, err := strconv.Atoi(command.DestinationTargetID); err == nil {
            p.activeGoroutineID = goroutineID(targetID)
        } else {
            command.RespondWithError(shared.ErrorCodeInternalError, "Could not convert targetID to int")
            panic(err)
        }
    }
    
    _, err := p.client.SwitchGoroutine(int(p.activeGoroutineID))
    if err != nil {
        command.RespondWithError(shared.ErrorCodeInternalError, err.Error())
        panic(err)
    }

    _, ok := <-p.client.Continue()
    if !ok {
        command.RespondWithError(shared.ErrorCodeInternalError, "It appears program has exited");
        return
    }
    command.Respond()
    p.sendPauseState()
}

func (p *proxy) stepOverAndRespond(command debuggerAgent.StepOverCommand) {
    if command.DestinationTargetID != "" {
        if targetID, err := strconv.Atoi(command.DestinationTargetID); err == nil {
            p.activeGoroutineID = goroutineID(targetID)
        } else {
            command.RespondWithError(shared.ErrorCodeInternalError, "Could not convert targetID to int")
            panic(err)
        }
    }
    
    _, err := p.client.SwitchGoroutine(int(p.activeGoroutineID))
    if err != nil {
        command.RespondWithError(shared.ErrorCodeInternalError, err.Error())
        panic(err)
    }

    _, err = p.client.Next()
    if err != nil {
        command.RespondWithError(shared.ErrorCodeInternalError, err.Error())
        panic(err)
    }
    command.Respond()
    p.sendPauseState()
}

func (p *proxy) stepIntoAndRespond(command debuggerAgent.StepIntoCommand) {
    if command.DestinationTargetID != "" {
        if targetID, err := strconv.Atoi(command.DestinationTargetID); err == nil {
            p.activeGoroutineID = goroutineID(targetID)
        } else {
            command.RespondWithError(shared.ErrorCodeInternalError, "Could not convert targetID to int")
            panic(err)
        }
    }
    
    _, err := p.client.SwitchGoroutine(int(p.activeGoroutineID))
    if err != nil {
        command.RespondWithError(shared.ErrorCodeInternalError, err.Error())
        panic(err)
        return
    }
    _, err = p.client.Step()
    if err != nil {
        command.RespondWithError(shared.ErrorCodeInternalError, err.Error())
        panic(err)
        return
    }
    command.Respond()
    p.sendPauseState()
}

func (p *proxy) stepOutAndRespond(command debuggerAgent.StepOutCommand) {
    if command.DestinationTargetID != "" {
        if targetID, err := strconv.Atoi(command.DestinationTargetID); err == nil {
            p.activeGoroutineID = goroutineID(targetID)
        } else {
            command.RespondWithError(shared.ErrorCodeInternalError, "Could not convert targetID to int")
            panic(err)
        }
    }
    
    _, err := p.client.SwitchGoroutine(int(p.activeGoroutineID))
    if err != nil {
        command.RespondWithError(shared.ErrorCodeInternalError, err.Error())
        panic(err)
        return
    }
    _, err = p.client.StepOut()
    if err != nil {
        command.RespondWithError(shared.ErrorCodeInternalError, err.Error())
        panic(err)
        return
    }
    command.Respond()
    p.sendPauseState()
}

func (p *proxy) setBreakpointAndRespond(command debuggerAgent.SetBreakpointByUrlCommand) {
    if command.UrlRegex != nil {
        command.RespondWithError(shared.ErrorCodeInvalidParams, "urlRegex not available")
        return
    }
    if command.ColumnNumber != nil && *command.ColumnNumber != 0 {
        command.RespondWithError(shared.ErrorCodeInvalidParams, "columnNumber not available")
        return
    }
    if command.Condition != nil && *command.Condition != "" {
        command.RespondWithError(shared.ErrorCodeInvalidParams, "condition not available")
        return
    }
    if command.Url == nil {
        command.RespondWithError(shared.ErrorCodeInvalidParams, "url must be set")
        return
    }
    if command.DestinationTargetID != "" {
        command.Respond(&debuggerAgent.SetBreakpointByUrlReturn{
            // TODO FIX THIS!
            BreakpointId: debuggerAgent.BreakpointId(fmt.Sprintf("%d", command.LineNumber)),
            Locations: []debuggerAgent.Location{
                buildLocation(*command.Url, int(*command.ColumnNumber)),
            },
        })
        return
    }
    breakpoint, err := p.client.CreateBreakpointAtLine(*command.Url, int(command.LineNumber))
    if err != nil {
        command.RespondWithError(shared.ErrorCodeInternalError, err.Error())
        return
    }
    command.Respond(&debuggerAgent.SetBreakpointByUrlReturn{
        BreakpointId: debuggerAgent.BreakpointId(fmt.Sprintf("%d", breakpoint.ID)),
        Locations: []debuggerAgent.Location{
            buildLocation(breakpoint.File, breakpoint.Line),
        },
    })
}

func (p *proxy) removeBreakpointAndRespond(command debuggerAgent.RemoveBreakpointCommand) {
    id, err := strconv.Atoi(string(command.BreakpointId))
    if err != nil {
        command.RespondWithError(shared.ErrorCodeInternalError, "Failed to convert BreakpointId to int")
        return
    }
    if err := p.client.ClearBreakpoint(id); err != nil {
        command.RespondWithError(shared.ErrorCodeInternalError, err.Error())
        return
    }
    command.Respond()
}

func (p *proxy) sendPauseState() {
    state, err := p.client.GetState()
    if err != nil {
        panic(err)
    }
    p.syncGoroutines()
    // TODO Need some checks here on state.
    if state == nil {
        fmt.Println("Called sendPauseState() but not paused.")
        return
    }

    var activeStack *[]dbgClient.Stackframe
    for routineID, target := range p.activeTargets {
        stacks, err := p.client.Stacktrace(int(routineID), 50, &dbgClient.LoadConfig{
            FollowPointers: true,
            MaxVariableRecurse: 1,
            MaxStringLen: 1,
            MaxArrayValues: 1,
            MaxStructFields: 1,
        })
        if err != nil {
            // TODO Something better here.
            panic(err)
        }
        if routineID == p.activeGoroutineID {
            activeStack = &stacks
            continue
        }
        target.FirePaused(stacks)
    }
    if activeStack != nil {
            // TODO move this code.
            sendFrames := []debuggerAgent.CallFrame{}
            for index, frame := range *activeStack {
                functionName := "<Unknown>"
                if frame.Location.Function != nil {
                    functionName = frame.Location.Function.Name
                }
                sendFrames = append(sendFrames, debuggerAgent.CallFrame{
                    CallFrameId: debuggerAgent.CallFrameId(fmt.Sprintf("%d", index)),
                    FunctionName: functionName,
                    Location: debuggerAgent.Location{
                        ScriptId: runtimeAgent.ScriptId(frame.Location.File),
                        LineNumber: int64(frame.Location.Line - 1), // Always -1
                    },
                    ScopeChain: []debuggerAgent.Scope{},
                    This: runtimeAgent.RemoteObject{
                        Type: "undefined",
                    },
                    ReturnValue: nil,
                })
            }
            p.agent.FirePaused(debuggerAgent.PausedEvent{
                Reason: "other",
                CallFrames: sendFrames,
            })
    }
}

func (p *proxy) syncGoroutines() {
    // TODO Need mutex for activeTargets.
    routines, err := p.client.ListGoroutines()
    if err != nil {
        panic(err)
    }
    foundTargets := map[goroutineID]struct{}{}
    for _, routine := range routines {
        id := goroutineID(routine.ID)
        foundTargets[id] = struct{}{}
        if id == p.activeGoroutineID {
            // Ignore activeGoroutine.
            continue
        }
        _, ok := p.activeTargets[id]
        if !ok {
            target := &Target{
                ID: id,
                Proxy: p,
            }
            target.Attach()
            p.activeTargets[id] = target
        }
    }
    for routineID, target := range p.activeTargets {
        if _, ok := foundTargets[routineID]; !ok {
            target.Destroy()
            delete(p.activeTargets, routineID)
        }
    }
    if _, ok := p.activeTargets[p.activeGoroutineID]; !ok {
        // Grab first item in activeTargets since one was not found.
        for index, _ := range p.activeTargets {
            p.activeGoroutineID = index
            break;
        }
    }
}

func getFileAndRespond(command debuggerAgent.GetScriptSourceCommand) {
    data, err := ioutil.ReadFile(string(command.ScriptId))
    if err != nil {
        //fmt.Println(err)
        panic(err)
        return
    }
    command.Respond(&debuggerAgent.GetScriptSourceReturn{
        ScriptSource: string(data),
    })
}
