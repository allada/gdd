package debugger

import (
    "fmt"
    "io/ioutil"
    "strconv"
    "sync"
    "crypto/sha1"
    //"time"
    "reflect"
    "../../dbgClient"
    "../../protocol/shared"
    debuggerAgent "../../protocol/debugger"
    runtimeAgent "../../protocol/runtime"
    targetAgent "../../protocol/target"
)

type goroutineID int

type Target struct {
    ID goroutineID
    Proxy *proxy
}

func (t *Target) Attach() {
    t.Proxy.target.FireAttachedToTarget(targetAgent.AttachedToTargetEvent{
        TargetInfo: targetAgent.TargetInfo{
            TargetId: targetAgent.TargetID(fmt.Sprintf("%d", t.ID)),
            Type: "worker",
            Title: "asdf",
            Url: "asdf",
        },
        WaitingForDebugger: false,
    })

    for _, file := range t.Proxy.fileList {
        t.Proxy.agent.FireScriptParsedOnTarget(fmt.Sprintf("%d", t.ID), debuggerAgent.ScriptParsedEvent{
            ScriptId: runtimeAgent.ScriptId(file),
            Url: file,
            ExecutionContextId: 1,
        })
    }
}

func (t *Target) Destroy() {
    t.Proxy.target.FireDetachedFromTarget(targetAgent.DetachedFromTargetEvent{
        TargetId: targetAgent.TargetID(fmt.Sprintf("%d", t.ID)),
    })
}

func (t *Target) FireResumed() {
    t.Proxy.agent.FireResumedOnTarget(fmt.Sprintf("%d", t.ID))
}

func (t *Target) FirePaused(callframes []dbgClient.Stackframe) {
    sendFrames := []debuggerAgent.CallFrame{}
    for index, frame := range callframes {
        functionName := "<Unknown>"
        if frame.Location.Function != nil {
            functionName = frame.Location.Function.Name
        }
        sendFrames = append(sendFrames, debuggerAgent.CallFrame{
            CallFrameId: debuggerAgent.CallFrameId(fmt.Sprintf("%d", index)),
            FunctionName: functionName,
            Location: debuggerAgent.Location{
                ScriptId: runtimeAgent.ScriptId(frame.Location.File),
                LineNumber: int64(frame.Location.Line - 1), // Always -1
            },
            ScopeChain: t.Proxy.buildScopeChain(),
            This: runtimeAgent.RemoteObject{
                Type: "undefined",
            },
            ReturnValue: nil,
        })
    }
    t.Proxy.agent.FirePausedOnTarget(fmt.Sprintf("%d", t.ID), debuggerAgent.PausedEvent{
        Reason: "other",
        CallFrames: sendFrames,
    })
}

type proxy struct {
    agent *debuggerAgent.DebuggerAgent
    target *targetAgent.TargetAgent
    client *dbgClient.Client
    activeTargets map[goroutineID]*Target
    fileList []string
    activeGoroutineID goroutineID
    breakpointsMux sync.Mutex
    breakpoints map[string]struct{}

    remoteObjects map[uintptr]runtimeAgent.RemoteObject
    runtime *runtimeAgent.RuntimeAgent
}

func NewProxy(conn *shared.Connection, client *dbgClient.Client) *proxy {
    agent := debuggerAgent.NewAgent(conn)
    target := targetAgent.NewAgent(conn)
    return &proxy{
        agent: agent,
        target: target,
        client: client,
        activeTargets: map[goroutineID]*Target{},
        breakpoints: map[string]struct{}{},
        remoteObjects: map[uintptr]runtimeAgent.RemoteObject{},
    }
}

func (p *proxy) Start(runtime *runtimeAgent.RuntimeAgent) {
    p.runtime = runtime
    // Wait until we are enabled.
    command := <-p.agent.EnableNotify()
    command.Respond()

    go p.handleNotifications()

    runtime.FireExecutionContextCreated(runtimeAgent.ExecutionContextCreatedEvent{
        Context: runtimeAgent.ExecutionContextDescription{
            Id: 1,
            Origin: "://",
            Name: "Self",
        },
    })

    // Wait until debugger is ready.
    p.client.BlockUntilReady()

    go p.sendPauseState()

    sources, err := p.client.ListSources()
    if err != nil {
        panic(err)
    }

    for _, source := range sources {
        if source == "<autogenerated>" {
            continue;
        }
        p.fileList = append(p.fileList, source)
        p.agent.FireScriptParsed(debuggerAgent.ScriptParsedEvent{
            ScriptId: runtimeAgent.ScriptId(source),
            Url: source,
            ExecutionContextId: 1,
        })
    }
}

func (p *proxy) GetRemoteObject(key string) (runtimeAgent.RemoteObject, bool) {
    conv, err := strconv.ParseUint(key, 10, 64)
    if err != nil {
        panic(err)
    }
    obj, ok := p.remoteObjects[uintptr(conv)]
    return obj, ok
}

func (p *proxy) handleNotifications() {
    enable                  := p.agent.EnableNotify()
    disable                 := p.agent.DisableNotify()
    setBreakpointsActive    := p.agent.SetBreakpointsActiveNotify()
    setSkipAllPauses        := p.agent.SetSkipAllPausesNotify()
    setBreakpointByUrl      := p.agent.SetBreakpointByUrlNotify()
    setBreakpoint           := p.agent.SetBreakpointNotify()
    removeBreakpoint        := p.agent.RemoveBreakpointNotify()
    getPossibleBreakpoints  := p.agent.GetPossibleBreakpointsNotify()
    continueToLocation      := p.agent.ContinueToLocationNotify()
    stepOver                := p.agent.StepOverNotify()
    stepInto                := p.agent.StepIntoNotify()
    stepOut                 := p.agent.StepOutNotify()
    pause                   := p.agent.PauseNotify()
    resume                  := p.agent.ResumeNotify()
    searchInContent         := p.agent.SearchInContentNotify()
    setScriptSource         := p.agent.SetScriptSourceNotify()
    restartFrame            := p.agent.RestartFrameNotify()
    getScriptSource         := p.agent.GetScriptSourceNotify()
    setPauseOnExceptions    := p.agent.SetPauseOnExceptionsNotify()
    evaluateOnCallFrame     := p.agent.EvaluateOnCallFrameNotify()
    setVariableValue        := p.agent.SetVariableValueNotify()
    setAsyncCallStackDepth  := p.agent.SetAsyncCallStackDepthNotify()
    setBlackboxPatterns     := p.agent.SetBlackboxPatternsNotify()
    setBlackboxedRanges     := p.agent.SetBlackboxedRangesNotify()

    // TODO this sucks and should be in runtime not here.
    getProperies := p.runtime.GetPropertiesNotify()
    // TODO bail out properly on closed.
    for {
        select {
        case command := <-enable:
            command.Respond()
            //command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-disable:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-setBreakpointsActive:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-setSkipAllPauses:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-setBreakpointByUrl:
            go p.setBreakpointAndRespond(command)
        case command := <-setBreakpoint:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-removeBreakpoint:
            go p.removeBreakpointAndRespond(command)
        case command := <-getPossibleBreakpoints:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-continueToLocation:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-stepOver:
            go p.stepOverAndRespond(command)
        case command := <-stepInto:
            go p.stepIntoAndRespond(command)
        case command := <-stepOut:
            go p.stepOutAndRespond(command)
        case command := <-pause:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-resume:
            go p.continueAndRespond(command)
        case command := <-searchInContent:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-setScriptSource:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-restartFrame:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-getScriptSource:
            // TODO this should be secure
            go getFileAndRespond(command)
        case command := <-setPauseOnExceptions:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-evaluateOnCallFrame:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-setVariableValue:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-setAsyncCallStackDepth:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-setBlackboxPatterns:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")
        case command := <-setBlackboxedRanges:
            command.RespondWithError(shared.ErrorCodeMethodNotFound, "")

        case command := <-getProperies:
            if string(command.ObjectId) == "local" {
                var goroutineID int
                var err error
                if command.DestinationTargetID == "" {
                    goroutineID = int(p.activeGoroutineID)
                } else {
                    goroutineID, err = strconv.Atoi(command.DestinationTargetID)
                    if err != nil {
                        panic(err)
                    }
                }
                variables, err := p.client.ListLocalVariables(dbgClient.EvalScope{
                    GoroutineID: goroutineID,
                    Frame: 0,
                }, dbgClient.LoadConfig{
                    FollowPointers: true,
                    MaxVariableRecurse: 1,
                    MaxStringLen: 500,
                    MaxArrayValues: 1,
                    MaxStructFields: 1,
                })
                if err != nil {
                    panic(err)
                }
                properties := []runtimeAgent.PropertyDescriptor{}
                for _, variable := range variables {
                    remoteObject := makeRemoteObject(variable)
                    properties = append(properties, runtimeAgent.PropertyDescriptor{
                        Name: variable.Name,
                        Value: &remoteObject,
                    })
                }
                command.Respond(&runtimeAgent.GetPropertiesReturn{
                    Result: properties,
                })
            }
        }
    }
}

func buildLocation(file string, line int) debuggerAgent.Location {
    return debuggerAgent.Location{
        ScriptId: runtimeAgent.ScriptId(file),
        LineNumber: int64(line),
    }
}

func (p *proxy) continueAndRespond(command debuggerAgent.ResumeCommand) {
    if command.DestinationTargetID != "" {
        if targetID, err := strconv.Atoi(command.DestinationTargetID); err == nil {
            p.activeGoroutineID = goroutineID(targetID)
        } else {
            command.RespondWithError(shared.ErrorCodeInternalError, "Could not convert targetID to int")
            panic(err)
        }
    }
    
    _, err := p.client.SwitchGoroutine(int(p.activeGoroutineID))
    if err != nil {
        command.RespondWithError(shared.ErrorCodeInternalError, err.Error())
        panic(err)
    }

    p.sendResumeState()
    _, ok := <-p.client.Continue()

    if !ok {
        command.RespondWithError(shared.ErrorCodeInternalError, "It appears program has exited");
        return
    }
    command.Respond()
    p.sendPauseState()
}

func (p *proxy) stepOverAndRespond(command debuggerAgent.StepOverCommand) {
    if command.DestinationTargetID != "" {
        if targetID, err := strconv.Atoi(command.DestinationTargetID); err == nil {
            p.activeGoroutineID = goroutineID(targetID)
        } else {
            command.RespondWithError(shared.ErrorCodeInternalError, "Could not convert targetID to int")
            panic(err)
        }
    }
    
    _, err := p.client.SwitchGoroutine(int(p.activeGoroutineID))
    if err != nil {
        command.RespondWithError(shared.ErrorCodeInternalError, err.Error())
        panic(err)
    }

    p.sendResumeState()
    _, err = p.client.Next()

    if err != nil {
        command.RespondWithError(shared.ErrorCodeInternalError, err.Error())
        panic(err)
    }
    command.Respond()
    p.sendPauseState()
}

func (p *proxy) stepIntoAndRespond(command debuggerAgent.StepIntoCommand) {
    if command.DestinationTargetID != "" {
        if targetID, err := strconv.Atoi(command.DestinationTargetID); err == nil {
            p.activeGoroutineID = goroutineID(targetID)
        } else {
            command.RespondWithError(shared.ErrorCodeInternalError, "Could not convert targetID to int")
            panic(err)
        }
    }
    
    _, err := p.client.SwitchGoroutine(int(p.activeGoroutineID))
    if err != nil {
        command.RespondWithError(shared.ErrorCodeInternalError, err.Error())
        panic(err)
        return
    }

    p.sendResumeState()
    _, err = p.client.Step()
    if err != nil {
        command.RespondWithError(shared.ErrorCodeInternalError, err.Error())
        panic(err)
        return
    }
    command.Respond()
    p.sendPauseState()
}

func (p *proxy) stepOutAndRespond(command debuggerAgent.StepOutCommand) {
    if command.DestinationTargetID != "" {
        if targetID, err := strconv.Atoi(command.DestinationTargetID); err == nil {
            p.activeGoroutineID = goroutineID(targetID)
        } else {
            command.RespondWithError(shared.ErrorCodeInternalError, "Could not convert targetID to int")
            panic(err)
        }
    }
    
    _, err := p.client.SwitchGoroutine(int(p.activeGoroutineID))
    if err != nil {
        command.RespondWithError(shared.ErrorCodeInternalError, err.Error())
        panic(err)
        return
    }

    p.sendResumeState()
    _, err = p.client.StepOut()
    if err != nil {
        command.RespondWithError(shared.ErrorCodeInternalError, err.Error())
        panic(err)
        return
    }
    command.Respond()
    p.sendPauseState()
}

func (p *proxy) setBreakpointAndRespond(command debuggerAgent.SetBreakpointByUrlCommand) {
    if command.UrlRegex != nil {
        command.RespondWithError(shared.ErrorCodeInvalidParams, "urlRegex not available")
        return
    }
    if command.ColumnNumber != nil && *command.ColumnNumber != 0 {
        command.RespondWithError(shared.ErrorCodeInvalidParams, "columnNumber not available")
        return
    }
    if command.Condition != nil && *command.Condition != "" {
        command.RespondWithError(shared.ErrorCodeInvalidParams, "condition not available")
        return
    }
    if command.Url == nil {
        command.RespondWithError(shared.ErrorCodeInvalidParams, "url must be set")
        return
    }

    // Start with "a" because cannot start just be a number.
    breakpointKey := fmt.Sprintf("a%x", sha1.Sum([]byte(fmt.Sprintf("%s:%d", *command.Url, command.LineNumber))))
    p.breakpointsMux.Lock()
    defer p.breakpointsMux.Unlock()
    if _, ok := p.breakpoints[breakpointKey]; ok {
        // Breakpoint already set.
        p.sendBreakpointSet(command, debuggerAgent.BreakpointId(breakpointKey))
        return
    }
    // Always +1 from what devtools says.
    _, err := p.client.CreateBreakpointAtLine(*command.Url, int(command.LineNumber + 1), breakpointKey)
    if err != nil {
        delete(p.breakpoints, breakpointKey)
        command.RespondWithError(shared.ErrorCodeInternalError, err.Error())
        return
    }
    p.breakpoints[breakpointKey] = struct{}{}
    p.sendBreakpointSet(command, debuggerAgent.BreakpointId(breakpointKey))
}

func (p *proxy) sendBreakpointSet(command debuggerAgent.SetBreakpointByUrlCommand, breakpointId debuggerAgent.BreakpointId) {
    command.Respond(&debuggerAgent.SetBreakpointByUrlReturn{
        //BreakpointId: debuggerAgent.BreakpointId(fmt.Sprintf("%d", breakpoint.ID)),
        BreakpointId: breakpointId,
        Locations: []debuggerAgent.Location{
            buildLocation(*command.Url, int(command.LineNumber)),
        },
    })
}

func (p *proxy) removeBreakpointAndRespond(command debuggerAgent.RemoveBreakpointCommand) {
    breakpointId := string(command.BreakpointId)
    p.breakpointsMux.Lock()
    delete(p.breakpoints, breakpointId)
    p.breakpointsMux.Unlock()
    if err := p.client.ClearBreakpointByName(breakpointId); err != nil {
        command.RespondWithError(shared.ErrorCodeInternalError, err.Error())
        return
    }
    command.Respond()
}

func (p *proxy) sendResumeState() {
    for _, target := range p.activeTargets {
        target.FireResumed()
    }
    p.agent.FireResumed()
}

func (p *proxy) sendPauseState() {
    state, err := p.client.GetState()
    if err != nil {
        panic(err)
    }
    p.syncGoroutines()
    // TODO Need some checks here on state.
    if state == nil {
        panic("Called sendPauseState() but not paused.")
    }

    var activeStack *[]dbgClient.Stackframe
    targetsStacks := map[*Target][]dbgClient.Stackframe{}
    for routineID, target := range p.activeTargets {
        stacks, err := p.client.Stacktrace(int(routineID), 50, &dbgClient.LoadConfig{
            FollowPointers: true,
            MaxVariableRecurse: 1,
            MaxStringLen: 1,
            MaxArrayValues: 1,
            MaxStructFields: 1,
        })
        if err != nil {
            // TODO Something better here.
            panic(err)
        }
        if routineID == p.activeGoroutineID {
            activeStack = &stacks
            continue
        }
        targetsStacks[target] = stacks
    }

    if activeStack != nil {
        // TODO move this code.
        sendFrames := []debuggerAgent.CallFrame{}
        for index, frame := range *activeStack {
            functionName := "<Unknown>"
            if frame.Location.Function != nil {
                functionName = frame.Location.Function.Name
            }
            sendFrames = append(sendFrames, debuggerAgent.CallFrame{
                CallFrameId: debuggerAgent.CallFrameId(fmt.Sprintf("%d", index)),
                FunctionName: functionName,
                Location: debuggerAgent.Location{
                    ScriptId: runtimeAgent.ScriptId(frame.Location.File),
                    LineNumber: int64(frame.Location.Line - 1), // Always -1
                },
                ScopeChain: p.buildScopeChain(),
                This: runtimeAgent.RemoteObject{
                    Type: "undefined",
                },
                ReturnValue: nil,
            })
        }
        p.agent.FirePaused(debuggerAgent.PausedEvent{
            Reason: "other",
            CallFrames: sendFrames,
        })
    }

    for target, stacks := range targetsStacks {
        target.FirePaused(stacks)
    }
}

func (p *proxy) buildScopeChain() []debuggerAgent.Scope {
    objectId := runtimeAgent.RemoteObjectId("local")
    return []debuggerAgent.Scope{
        debuggerAgent.Scope{
            Type: debuggerAgent.ScopeTypeLocal,
            Object: runtimeAgent.RemoteObject{
                Type: runtimeAgent.RemoteObjectTypeObject,
                ObjectId: &objectId,
            },
        },
    }
}

func (p *proxy) syncGoroutines() {
    // TODO Need mutex for activeTargets.
    routines, err := p.client.ListGoroutines()
    if err != nil {
        panic(err)
    }
    foundTargets := map[goroutineID]struct{}{}
    for _, routine := range routines {
        id := goroutineID(routine.ID)
        foundTargets[id] = struct{}{}
        if id == p.activeGoroutineID {
            // Ignore activeGoroutine.
            continue
        }
        _, ok := p.activeTargets[id]
        if !ok {
            target := &Target{
                ID: id,
                Proxy: p,
            }
            target.Attach()
            p.activeTargets[id] = target
        }
    }
    for routineID, target := range p.activeTargets {
        if _, ok := foundTargets[routineID]; !ok {
            target.Destroy()
            delete(p.activeTargets, routineID)
        }
    }
    if _, ok := p.activeTargets[p.activeGoroutineID]; !ok {
        // Grab first item in activeTargets since one was not found.
        for index, _ := range p.activeTargets {
            p.activeGoroutineID = index
            break;
        }
    }
}

func getFileAndRespond(command debuggerAgent.GetScriptSourceCommand) {
    data, err := ioutil.ReadFile(string(command.ScriptId))
    if err != nil {
        //fmt.Println(err)
        panic(err)
        return
    }
    command.Respond(&debuggerAgent.GetScriptSourceReturn{
        ScriptSource: string(data),
    })
}

func makeRemoteObject(variable dbgClient.Variable) runtimeAgent.RemoteObject {
    //name := variable.Name
    kind := variable.Kind
    outKind := runtimeAgent.RemoteObjectTypeSymbol
    var subType runtimeAgent.RemoteObjectSubtypeEnum
    var subTypePtr *runtimeAgent.RemoteObjectSubtypeEnum

    previewType := runtimeAgent.ObjectPreviewTypeSymbol
    var previewSubType runtimeAgent.ObjectPreviewSubtypeEnum
    var previewSubTypePtr *runtimeAgent.ObjectPreviewSubtypeEnum
    if kind == reflect.Bool {
        outKind = runtimeAgent.RemoteObjectTypeBoolean
    } else if kind == reflect.Int || kind == reflect.Int8 || kind == reflect.Int16 || kind == reflect.Int32 ||
              kind == reflect.Int64 || kind == reflect.Uint || kind == reflect.Uint8 || kind == reflect.Uint16 ||
              kind == reflect.Uint32 || kind == reflect.Uint64 || kind == reflect.Uintptr || kind == reflect.Float32 ||
              kind == reflect.Float64 {
        outKind = runtimeAgent.RemoteObjectTypeNumber
    } else if kind == reflect.Complex64 || kind == reflect.Complex128 {
    } else if kind == reflect.Array {
        outKind = runtimeAgent.RemoteObjectTypeObject
        subType = runtimeAgent.RemoteObjectSubtypeArray
        subTypePtr = &subType

        previewType = runtimeAgent.ObjectPreviewTypeObject
        previewSubType = runtimeAgent.ObjectPreviewSubtypeArray
        previewSubTypePtr = &previewSubType
    } else if kind == reflect.Chan {
    } else if kind == reflect.Func {
        outKind = runtimeAgent.RemoteObjectTypeFunction
    } else if kind == reflect.Interface {
    } else if kind == reflect.Map {
        outKind = runtimeAgent.RemoteObjectTypeObject
        subType = runtimeAgent.RemoteObjectSubtypeMap
        subTypePtr = &subType
    } else if kind == reflect.Ptr {
    } else if kind == reflect.Slice {
        outKind = runtimeAgent.RemoteObjectTypeObject
        subType = runtimeAgent.RemoteObjectSubtypeArray
        subTypePtr = &subType
    } else if kind == reflect.String {
        outKind = runtimeAgent.RemoteObjectTypeString
        previewType = runtimeAgent.ObjectPreviewTypeString
    } else if kind == reflect.Struct {
        outKind = runtimeAgent.RemoteObjectTypeObject
    } else if kind == reflect.UnsafePointer {
    }

    return runtimeAgent.RemoteObject{
        Type: outKind,
        Subtype: subTypePtr,
        Value: variable.Value,
        Preview: &runtimeAgent.ObjectPreview{
            Type: previewType,
            Subtype: previewSubTypePtr,
            Overflow: false,
            Properties: []runtimeAgent.PropertyPreview{},
            // Entries: &[]runtimeAgent.EntryPreview{},
        },
    }
}
